# 插入文档

使用集合的 insertOne 方法插入单个文档
insertOne 会为文档自动添加一个 "_id" 键（如果你没有提供的话），并将其保存到 MongoDB 中。
> db.movies.insertOne({"title" : "Stand by Me"})

## insertMany
如果要向一个集合中插入多个文档，那么可以使用 insertMany。

使用 insertMany 执行批量插入时，如果中途某个文档发生了某种类型的错误，那么接下来会发生什么取决于所选择的是有序操作还是无序操作。可以指定一个选项文档作为 insertMany 的第二个参数。将选项文档中的 "**ordered**" 键指定为true，可以确保文档按提供的顺序插入。指定为 false 则允许 MongoDB 重新排列插入的顺序以提高性能。如果未特别指定，则默认为有序插入。对于有序插入，插入顺序由传递给 insertMany 的数组进行定义。如果一个文档产生了插入错误，则数组中`在此之后的文档均不会被插入集合中`。对于无序插入，MongoDB `将尝试插入所有文档，而不管某些插入是否产生了错误`。

## 插入校验

MongoDB 会对要插入的数据进行最基本的检查：
- 检查文档的基本结构，如果不存在 "\_id" 字段，则自动添加一个。
- 所有文档都必须小于 16MB。
由于仅做最基本的检查，这意味着可以很`容易地插入无效数据`

## 插入

- 在 MongoDB 3.0 之前，**insert** 是在 MongoDB 中插入文档的主要方法。
- 从MongoDB 3.2 开始，mongo shell 也支持这种 API，它包括 **insertOne** 和**insertMany** 以及其他一些方法。

虽然 insert 等方法仍然支持向后兼容，但今后`不应该在应用程序中继续使用`。应该使用 insertOne 和 insertMany 来创建文档。

# 删除文档

现在要删除数据库中的一些数据。CRUD API 为此提供了 **deleteOne** 和 **deleteMany** 两种方法。

这两种方法都将`筛选文档`（filter document）作为`第一个参数`。筛选文档指定了在删除文档时要与之匹配的一组条件。

可以使用 deleteMany 来删除满足筛选条件的所有文档。

- 在 MongoDB 3.0 之前，remove 是删除文档的主要方法。
- 在 MongoDB 3.0 之前，remove 是删除文档的主要方法。

尽管 remove 仍然支持向后兼容，但你应该在应用程序中使用 deleteOne 和 deleteMany。*当前的 CRUD API 提供了更整洁的语义，尤其在多文档操作中，可以帮助应用程序开发人员避开之前API 中存在的很多常见陷阱。*

## 删除集合

可以使用 **deleteMany** 来删除一个集合中的所有文档

删除文档的操作通常会比较快。不过，如果想清空整个集合，那么使用 **drop** 直接删除集合，然后在这个空集合中重建各项索引会更快

# 更新文档

将文档存入数据库中之后，可以使用以下几种更新方法之一对其进行更改：updateOne、updateMany 和 replaceOne。

与删除文档相同，这三个API都将筛选文档作为第一个参数。

更新文档是`原子操作`：如果两个更新同时发生，那么首先到达服务器的更新会先被执行，然后再执行下一个更新。

## 文档替换

**replaceOne** 会用新文档完全替换匹配的文档。
一个常见的错误是查询条件匹配到了多个文档，然后更新时由第二个参数产生了`重复的 "\_id" 值`。数据库会抛出错误，任何文档都不会被更新。

## 使用更新运算符

通常文档只会有一部分需要更新。可以使用原子的更新运算符（update operator）更新文档中的特定字段。更新运算符是特殊的键，可用于指定复杂的更新操作，比如`更改、添加或删除键，甚至可以操作数组和内嵌文档`。

