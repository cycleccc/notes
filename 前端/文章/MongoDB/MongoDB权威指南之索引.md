# 前言
本章介绍 MongoDB 的索引。索引使你能够高效地执行查询。它们是应用程序开发的重要组成部分，甚至对于某些类型的查询是必需的。

# 索引简介
数据库索引类似于图书索引。有了索引便不需要浏览整本书，只查看一个有内容引用的有序列表。这使得 MongoDB 的查找速度提高了`好几个数量级`。

不使用索引的查询称为`集合扫描`，这意味着服务器端必须“浏览整本书”才能得到查询的结果。

**查询模式**

为了使 MongoDB 高效地响应查询，应用程序中的所有查询模式都应该有`索引支持`。

所谓查询模式，是指`应用程序向数据库提出的不同类型的问题`。例如按用户名查询 users 集合。这就是一个特定查询模式的示例。

## 创建索引

创建索引可以使用 **createIndex** 集合方法。

```shell
> db.users.createIndex({"username" : 1})
{
    "createdCollectionAutomatically" : false,
    "numIndexesBefore" : 1,
    "numIndexesAfter" : 2,
    "ok" : 1
}
```

创建索引只需几秒的时间，除非集合特别大。如果 createIndex 调用在几秒后没有返回，则可以运行 `db.currentOp()`（在另一个 shell 中）或检查 `mongod 的日志`以查看索引创建的进度。

索引可以显著缩短查询时间。然而，`使用索引是有代价的`：修改索引字段的写操作（插入、更新和删除）会花费更长的时间。这是因为在更改数据时，除了更新文档，MongoDB 还`必须更新索引`。

要选择为哪些字段创建索引，可以查看常用的查询、需要快速执行的查询以及遇到性能瓶颈的查询，并尝试从中找到一组通用的键。

## 复合索引简介

对于许多查询模式来说，在两个或更多的键上创建索引是必要的。

例如，可以在 "age" 和"username" 上创建索引，如果查询中有多个排序方向或者查询条件中有多个键，那么这个索引会非常有用。

```JavaScript
> db.users.createIndex({"age" : 1, "username" : 1})
```

上例创建的称为`复合索引`（compound index）。复合索引是创建在多个字段上的索引。

## MongoDB如何选择索引

当有查询进来时，MongoDB 会查看这个查询的形状。这个形状与要搜索的字段和一些附加信息（比如是否有排序）有关。基于这些信息，系统会识别出一组可能用于满足查询的候选索引。

假设有一个查询进入，5 个索引中的 3 个被标识为该查询的候选索引。然后，MongoDB 会创建 3 个查询计划，分别为每个索引创建 1 个，并在 3 个并行线程中运行此查询，每个线程使用不同的索引。这样做的目的是看哪一个能够最快地返回结果。可以将其看作一场竞赛，到达目标状态的第一个查询计划成为赢家。但更重要的是，以后会选择它作为索引，用于具有相同形状的其他查询。每个计划会相互竞争一段时间（称为试用期），之后每一次竞赛的结果都会用来在总体上计算出一个获胜的计划。

![[Pasted image 20231103114453.png]]


## 使用复合索引

在考虑复合索引的设计时，需要知道对于利用索引的通用查询模式，如何处理其`等值过滤`、`多值过滤`以及`排序`这些部分。对于所有复合索引都必须考虑这 3 个因素，而且如果在设计索引时可以正确地平衡这些关注点，那么你的查询就会从MongoDB 中获得最佳的性能。

为了避免内存排序，需要检查比返回的文档数量更多的键，这对于复合索引来说往往是必需的。为了使用索引进行排序，MongoDB 应该能够按顺序遍历索引键。这意味着需要在复合索引键中包含排序字段。

概括来说，在设计复合索引时：

- 等值过滤的键应该在最前面
- 用于排序的键应该在多值字段之前
- 多值过滤的键应该在最后面。

在设计复合索引时遵循这些准则，然后在实际工作负载下进行测试，这样就可以确定索引所支持的查询模式有哪些了。

**选择键的方向**

只有基于多个查询条件进行排序时，索引方向才是重要的。如果只是基于一个键进行排序，那么 MongoDB 可以简单地从相反方向读取索引。

**使用覆盖查询**

当一个索引包含用户请求的所有字段时，这个索引就覆盖了本次查询。只要切实可行，就应该优先使用`覆盖查询`，而不是去获取实际的文档，这样可以使工作集大幅减小。

**隐式索引**

复合索引具有“双重功能”，而且针对不同的查询可以充当不同的索引。如果有一个拥有 N 个键的索引，那么你同时“免费”得到了所有这些键的前缀所组成的索引。如果有一个类似 {"a": 1, "b": 1, "c": 1 ..., "z": 1} 这样的索引，那么实际上也等于有了 {"a": 1}、{"a": 1, "b" : 1}、{"a": 1,"b": 1, "c": 1} 等一系列索引。

## $运算符如何使用索引


**隐式查询**