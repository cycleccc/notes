## **[L1-080 乘法口诀数列]([题目详情 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652359))**

本题要求你从任意给定的两个 1 位数字 *a*1 和 *a*2 开始，用乘法口诀生成一个数列 {*a**n*}，规则为从 *a*1 开始顺次进行，每次将当前数字与后面一个数字相乘，将结果贴在数列末尾。如果结果不是 1 位数，则其每一位都应成为数列的一项。

### 输入格式：

输入在一行中给出 3 个整数，依次为 *a*1、*a*2 和 *n*，满足 0≤*a*1,*a*2≤9，0<*n*≤103。

### 输出格式：

在一行中输出数列的前 *n* 项。数字间以 1 个空格分隔，行首尾不得有多余空格。

### 输入样例：

```in
2 3 10
```

### 输出样例：

```out
2 3 6 1 8 6 8 4 8 4
```

### 样例解释：

数列前 2 项为 2 和 3。从 2 开始，因为 2×3=6，所以第 3 项是 6。因为 3×6=18，所以第 4、5 项分别是 1、8。依次类推…… 最后因为第 6 项有 6×8=48，对应第 10、11 项应该是 4、8。而因为只要求输出前 10 项，所以在输出 4 后结束。

​		*我确实是太菜了，主要也是没有逃离舒适圈去认真面对不熟悉的东西，这道题完全不该有错，用to_string函数又快又简单，在比赛的时候暴力循环又循环，产生了段错误都不知道怎么改，导致最后和国奖失之交臂，机会不多了，亡羊补牢吧。*

##### 正确代码如下:

~~~c
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 100005;
int maxn    = 0;
int minn    = 0x3f3f3f3f;

int a[N];

void solve() {
    int n;
    cin >> a[1] >> a[2] >> n;
    int cnt = 3;
    for (int i = 3; i <= n; i++) {
        int x    = a[i - 1] * a[i - 2];
        string s = to_string(x);
        for (int j = 0; j < s.size(); j++) {
            a[cnt++] = s[j] - '0';
        }
    }
    for (int i = 1; i <= n; i++) {
        if (i != n) cout << a[i] << " ";
        else
            cout << a[i];
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
~~~

