[toc]

# 面试一

## 自我介绍

这一块是有准备的但是可能不算特别好，后续再看一下别人是怎么介绍的

## 性格介绍

让我介绍三个优点，这我真没想到，着实把我给难住了，导致我语言及其不清晰

## 项目介绍

开始的时候看面经没有人说项目介绍怎样怎样，都去准备八股文了，这一块没准备，也是寄了，后续准备了一下

要说出项目的整体架构，项目模块特色等

## 项目难点介绍

这个两次面试也都问了，我第一次没准备就说不出来，第二次说权限管理也没有继续追问

## **查漏补缺**

重新准备了项目介绍以及性格介绍

# 面试二

## 自我介绍

与第一次相同

## 项目介绍

准备了但是面试官没有深入的问

## 八股文问答

八股文需要更深入，面试官似乎没有兴趣引导我深入的去挖掘每个知识点的细节，得靠自己说

## 查漏补缺

js的基础类型和引用类型

基本类型

- number、string、boolean、null、undefined、symbol

引用类型

- object、function、array

数组去重

方法足有十几种之多，且都是利用了以下两个特点

- 利用语法自身键值不可重复
- 两层循环

es5时用的最多的是双层for循环使用splice去重

es6时用的最多的是set去重

router和route的区别

$route：是一个跳转的路由对象，每一个路由都会有一个`$route`对象，可以获取当前路由的path，name，params，query等属性

$router：是VueRouter的一个对象，通过Vue.use(VueRouter)和Vue构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性

vue上的属性

![image-20220518155959224](面试题/面试总结.assets/image-20220518155959224-16528608028981.png)

## promise

Promise是异步微任务，解决了异步多层嵌套回调的问题也就是回调地狱，让代码可读性更高。

# 面试三

项目太差了，重来一次我肯定不会再写商城了

## 查漏补缺

### vue.router的hash模式与history模式

#### hash模式

使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化， 执行相应的js切换网页

- hash指的是#号后面的字符也成为散列值，hash也称为锚点，本身用来做页面跳转定位。
- 散列值不会随请求发送到服务器端，所以改变hash，不会重新加载页面。
- 监听window的hashchange事件，当散列值改变时，可以通过location.hash来获取和设置hash值。
- location.hash值的变化会直接反应到浏览器地址栏。

##### 触发hashchange事件的几种情况

- 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；
- 当浏览器地址栏中URL包含哈希如 `http://www.baidu.com/#home`，这时按下输入，浏览器发送`http://www.baidu.com/`请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；
- 当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；
- html中`<a>`标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；

#### history模式

window.history属性指向history对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。history对象保存了当前窗口访问过的所有页面网址。通过history.length可以得出当前一共访问过几个网址。浏览器工具栏的前进和后退按钮就是对history对象进行操作。

##### 两个属性

- history.length：当前窗口访问过的网址数量
- history.state：history堆栈最上层的状态值

##### 方法

- back()、forward()、go()三个方法用于在历史中移动（浏览器的前进后退键就是这几个方法）

##### pushState、replaceState

用来修改浏览器的历史记录，三个参数（object，title，url）

##### popState事件

仅调用pushState和replaceState不会触发popState只有点击浏览器倒退前进按钮和back、forward、go才会触发。

### vue双向数据绑定细节

[双向数据绑定是什么 ](https://vue3js.cn/interview/vue/bind.html#一、什么是双向绑定)

#### MVVM模型

#### ViewModel

主要职责

- 数据变化后更新视图
- 视图变化后更新数据

两个重要组成部分

- 监听器（Observer）：对所有数据的属性进行监听
- 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析，根据指令摸板替换数据以及绑定相应的跟新函数

#### 名词解释

- Obsever：用来劫持并监听所有属性，如果有变动的，就通知订阅者。
  - 实现：通过递归方法遍历所有属性值，并对其进行Object.defineProperty()处理
- Watcher：可以收到属性的变化通知并执行相应的函数，从而更新视图。
  - 
- Compile：可以扫描和解析每个节点的相关指令，并根据初始化摸板数据以及初始化相应的订阅器。

### hash表、hash冲突

#### 基本概念

##### 哈希算法

根据设定的哈希函数H（key）和处理冲突方法将一组关键字映像到一个有限的地址区间上的算法。也称为散列算法、杂凑算法。

##### 哈希表

数据经过哈希算法之后得到的集合。这样关键子和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询。

##### 哈希冲突

由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同

#### 解决哈希冲突的方法

##### 2.1开放定址法

发生冲突后按照一定的次序再找一个空闲的单元。

##### 2.1.1线性探查法

线性探查法是开放定址法最简单的冲突处理方法，它从发生冲突的单元起，一次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。

##### 2.1.2 平方探查法

平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。

##### 2.1.3 双散列函数探查法

这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。

#### 2.2 链地址法（拉链法）

链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

#### 2.3 再哈希法

就是同时构造多个不同的哈希函数： Hi = RHi(key)   i= 1,2,3 … k; 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

#### 2.4 建立公共溢出区

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

### 设计模式

# 面试四

## 项目

### 封装通用组件

#### 轮播图组件

使用了swiperjs库实现了对传入图片列表的分页处理

#### 分页组件

实现了分页逻辑的计算

### 支付功能

### 密码加密

> 也是感谢这一家，让我知道了可以对项目进行包装的一个点。

# 面试五

## 项目

简单介绍了一下，和以前讲的差不多，加上了aes+rsa加密，但是没讲清楚，后面再做项目希望能用node.js真正实现一下。

## CSS

面试了很多次就这一家考了我CSS，字节好像也考了，忘了。

让我实现一个圆，我说用border啥的属性设为50%,那时候忘记了border-radius。。。

## 字符串倒序问题

# 面试六

> 字节面试